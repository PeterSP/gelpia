#!/usr/bin/env python3

import argparse as AP
import time as T
import sys as SYS
import os as OS
import os.path as PATH
import ast as AST
import re as RE
import sys as SYS
import subprocess as SP
import collections as COL

import ian_utils as IU


def mk_file_hash(function):
    h  = hash(function)
    h *= hash(T.time())
    h *= OS.getpid()
    return hex(h % (1 << 48))[2:] # Trim 0x


def parse_box2(box_string):
    #mark please comment this function
    # Put numbers in strings
    # num_re = r"((?:-?\d+\.\d+)|(?:-?\d+\.)|(?:-?\.\d+)|(?:-?\d+))"
    # interval_re = r"\((" + num_re + r"),\s*(" + num_re + ")\)"
    import input_parser
    box_string = input_parser.process(box_string[0])
    # box_string = RE.sub(interval_re,
    #                     lambda m: '("{}", "{}")'.format(m.group(1), m.group(3)),
    #                     box_string[0])
    python_box = COL.OrderedDict(sorted(AST.literal_eval(box_string).items(), key=lambda t: t[0]))
    variables = dict()
    index = 0
    box = []
    try:
        dimensions = len(python_box)
        for pair in python_box.keys():
            variables[pair] = index
            index += 1
            pair = python_box[pair]
            if (len(pair) != 2):
                IU.error("Interval must be a N by 2 list.")
                IU.error("item <{}> is of length {}".format(pair, len(pair)))
                SYS.exit()
            if (not isinstance(pair[0], str) or
                not isinstance(pair[1], str)):
                IU.error("Improve this error 0")
                SYS.exit()
            box.append(pair)

        return (box, 
                dimensions, 
                variables)

    except:
        IU.error("Improve this error 1")
        raise
        SYS.exit()





def parse_args():
    """ Command line argument parser. Returns a dict from arg name to value"""

    # Using the Ian argument parser since it has nicer from file characteristics
    parser = IU.IanArgumentParser(description="Global function optimizer based "
                                  "on branch and bound for noncontinuous "
                                  "functions.",
                                  fromfile_prefix_chars='@')
    # Verbosity level
    parser.add_argument("-v", "--verbose", help="increase output verbosity",
                        type=int, default=0)
    parser.add_argument("-ie", "--input-epsilon",
                        help="cuttoff for function input size",
                        type=float, default=.001)
    parser.add_argument("-oe", "--output-epsilon",
                        help="cuttoff for function output size",
                        type=float, default=.001)
    parser.add_argument("-i", "--input",
                        help="Search space. "
                        "Format is: {V1 : (inf_V1, sup_V1), ...}"
                        "Where V1 is the interval name, inf_V1 is the infimum, "
                        "and sup_V1 is the supremum",
                        type=str, nargs='+', required=True,)
    parser.add_argument("-f", "--function",
                        help="the c++ interval arithmatic function to evaluate",
                        type=str, nargs='+', required=True,)
    parser.add_argument("-d", "--debug",
                        help="Debug run of function. Makes the minimum verbosity"
                        " level one. Runs a debug build of gelpia, "
                        "with backtrace enabled.", action="store_true")
    parser.add_argument("-t", "--timeout",
                        help="Timeout for execution in seconds.",
                        default=0)
    parser.add_argument("-u", "--update",
                        help="Time between update thread executions.",
                        default=10)
    parser.add_argument("-L", "--logging",
                        help="Enable solver logging to stderr",
                        type=str, nargs='?', const=True, default=None)

    # actually parse
    args = parser.parse_args()

    # set verbosity level
    if args.debug or args.verbose:
        IU.set_log_level(max(1, args.verbose))

    # grab function (this is required since the function may have spaces in it)
    # `input` is handled differently
    function = ' '.join(args.function)

    return {"input_epsilon"  : str(args.input_epsilon),
            "output_epsilon" : str(args.output_epsilon),
            "input"          : args.input,
            "function"       : function,
            "debug"          : args.debug,
            "timeout"        : str(args.timeout),
            "update"         : str(args.update),
            "logging"        : args.logging is not None,
            "logfile"        : args.logging if isinstance(args.logging, str) else None}

def make_X_0(box_list):
    """ Makes a box from the given python structure"""
    box = list()
    for i in range(len(box_list)):
        box.append(box_list[i][0], box_list[i][1])
    return box


def append_to_environ(pathname, addition):
    try:
        OS.environ[pathname] = "{}:{}".format(addition,
                                              OS.environ[pathname])
    except KeyError:
        OS.environ[pathname] = addition


def setup_requirements(base_dir):
    # Add to paths used during runtime for requirements
    path_addition = PATH.join(base_dir, "requirements/bin")
    append_to_environ("PATH", path_addition)

    ld_lib_addition = PATH.join(base_dir, "requirements/lib")
    append_to_environ("LD_LIBRARY_PATH", ld_lib_addition)

    lib_addition = PATH.join(base_dir, "requirements/lib")
    append_to_environ("LIBRARY_PATH", lib_addition)

    c_inc_addition = PATH.join(base_dir, "requirements/include")
    append_to_environ("C_INCLUDE_PATH", c_inc_addition)

    cplus_inc_addition = PATH.join(base_dir, "requirements/include")
    append_to_environ("CPLUS_INCLUDE_PATH", cplus_inc_addition)



def main():
    parsing_start = T.time()
    arg_dict = parse_args()

    # Directory names used in this script
    full_dir = PATH.abspath(PATH.dirname(SYS.argv[0])) # Directory for this file
    base_dir = PATH.split(full_dir)[0] # One directory up
    src_dir = PATH.join(base_dir, "src")
    bin_dir = PATH.join(base_dir, "bin")
    setup_requirements(base_dir)

    # Add to paths used during runtime for our rust libs
    append_to_environ("PATH", bin_dir)
    rust_ld_lib_addition = PATH.join(base_dir, ".compiled")
    if arg_dict["debug"]:
        rust_ld_lib_addition += ":" + PATH.join(base_dir, "src/func/target/debug/")
        rust_ld_lib_addition += ":" + PATH.join(base_dir, "target/debug/deps")
        # Set debug mode in case of a crash
        append_to_environ("RUST_BACKTRACE", "1")
    else:
        rust_ld_lib_addition += ":" + PATH.join(base_dir, "src/func/target/release/")
        rust_ld_lib_addition += ":" + PATH.join(base_dir, "target/release/deps")
    append_to_environ("LD_LIBRARY_PATH", rust_ld_lib_addition)

    # Grab input interval variables, use them for the function translation,
    # and write them out to a rust file
    start_box, dimensions, variables = parse_box2(arg_dict["input"])
    import function_to_rust
    tup = function_to_rust.translate(arg_dict["function"], variables)
    (function, constants, part) = tup

    inputs = ["[{}, {}]".format(x[0], x[1]) for x in start_box]
    inputs = "|".join(inputs)

    file_id = mk_file_hash(arg_dict["function"])
    function_filename = PATH.join(src_dir, 
                                  "func/src/lib_generated_{}.rs".format(file_id))

    names = [None for i in range(len(variables))]
    for i in variables.keys():
        names[variables[i]] = i

    if arg_dict["debug"]:
        executable = PATH.join(base_dir, 'target/debug/cooperative')
    else:
        executable = PATH.join(base_dir, 'target/release/cooperative')

    # Log output
    executable_args = ['-c', constants,
                       '-f', part,
                       '-i', inputs,
                       "-x", arg_dict["input_epsilon"],
                       "-y", arg_dict["output_epsilon"],
                       "-S", "generated_"+file_id, # Function file suffix
                       "-n", ",".join(names),
                       "-t", arg_dict["timeout"],
                       "-u", arg_dict["update"],
                       "-d" if arg_dict["debug"] else "", # If a debug run
                       "-L" if arg_dict["logging"] else ""] 
    
    IU.log(1, IU.cyan("Interpreted: ") + part)
    IU.log(1, IU.cyan("Rust: ") + function)
    IU.log(1, IU.cyan("Domain: ") + inputs)
    IU.log(1, IU.cyan("Variables: ") + ", ".join(names))
    IU.log(1, IU.cyan("Command: ") + str(' '.join([executable]+executable_args)))

    parsing_end = T.time()

# Use try so that we can catch control-c easily
    output = None
    log_file = arg_dict["logfile"];
    logging = arg_dict["logging"];

    try:
        print(function_filename);
        with open(function_filename, 'w') as f:
            f.write(function)

        if log_file is not None:
            with open(log_file, 'w') as f2:
                f2.write("")
                f2.flush()
            
        start = T.time()
        IU.log(1, IU.cyan("Running"))
        for line in IU.run_async(executable, executable_args):
            if logging and line.startswith("lb:"): # Hacky
                print(line.strip(), file=SYS.stderr)
                if log_file is not None:
                    with open(log_file, 'a') as f2:
                        f2.write(line.strip())
                        f2.write('\n')
                        f2.flush()
            else:
                print(line.strip())
    except KeyboardInterrupt:
        IU.warning("Caught ctrl-C, exiting now")
    finally:
        OS.remove(function_filename)
        try:
            OS.remove(PATH.join(base_dir, "/.compiled/libfunc_"+file_id+".so"))
        except:
            pass
        end = T.time()
    
    if output:
        print(output)

    IU.log(0, IU.green("Parsing time: ")+str(parsing_end-parsing_start))
    IU.log(0, IU.green("Solver time: ")+str(end-start))

    
if __name__ == "__main__":
    main()
