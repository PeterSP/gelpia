#!/usr/bin/env python3

import ian_utils as IU
import line_profiler as LP
import argparse as AP
import time as T
import sys as SYS
import os.path as P
import os as OS
import ast as AST
import re as RE
import sys as SYS

solvers = {"serial"                 : "serial",
           "s"                      : "serial", 
           "priority_serial"        : "priority_serial",
           "ps"                     : "priority_serial",
           "naive_parallel"         : "naive_parallel",
           "np"                     : "naive_parallel",
	   "split_parallel"         : "split_parallel",
	   "sp"                     : "split_parallel"}

GU = None
SOLVER = None
def import_solver(solver):
    global SOLVER
    if solvers[solver] == "serial":
        import serial_solver as SOLVER
    if solvers[solver] == "priority_serial":
        import priority_serial_solver as SOLVER
    if solvers[solver] == "naive_parallel":
        import naive_parallel_solver as SOLVER
    if solvers[solver] == "split_parallel":
        import split_parallel_solver as SOLVER


def parse_box(box_string):
    num_re = r"((?:-?\d+\.\d+)|(?:-?\d+\.)|(?:-?\.\d+)|(?:-?\d+))"
    box_string = RE.sub(num_re, 
                        lambda m: '"{}"'.format(m.group(1)), 
                        box_string[0])
    python_box = AST.literal_eval(box_string)
    
    try:
        dimentions = len(python_box)
        box = GU.box()

        for pair in python_box:
            if (len(pair) != 2):
                IU.error("Interval must be a N by 2 list.")
                IU.error("item <{}> is of length {}".format(pair, len(pair)))
                SYS.exit()
            if (not isinstance(pair[0], str) or 
                not isinstance(pair[1], str)):
                IU.error("Improve this error 0")
                SYS.exit()
            box.append(pair[0], pair[1])
        
        return (box, dimentions)

    except:
        IU.error("Improve this error 1")
        raise
        SYS.exit()




def parse_args():
    parser = IU.IanArgumentParser(description="Temporary description",
                               fromfile_prefix_chars='@')
    parser.add_argument("-v", "--verbose", help="increase output verbosity",
                        type=int)
    parser.add_argument("-p", "--profile", help="profile the solver",
                        action="store_true")
    parser.add_argument("-t", "--threads", help="number of threads to use",
                        type=int, default=1)
    parser.add_argument("-ie", "--input-epsilon",
                        help="cuttoff for function input size",
                        type=float, default=.001)
    parser.add_argument("-oe", "--output-epsilon",
                        help="cuttoff for function output size",
                        type=float, default=.001)
    parser.add_argument("-s", "--solver",
                        help="solver to use",
                        choices = solvers.keys(),
                        type=str, default="serial")
    parser.add_argument("-i", "--input",
                        nargs='+', required=True,
                        help="Search space",
                        type=str)
    parser.add_argument("-f", "--function",
                        nargs='+', required=True,
                        help="the c++ interval arithmatic function to evaluate",
                        type=str)

    args = parser.parse_args() 

    if args.verbose:
        IU.set_log_level(args.verbose)
        
    function = ' '.join(args.function)


    return {"input_epsilon"  : str(args.input_epsilon),
            "output_epsilon" : str(args.output_epsilon),
            "input"          : args.input,
            "function"       : function,
            "solver"         : args.solver,
            "threads"        : args.threads,
            "profile"        : args.profile}




def create_function_body(function):
    preamble = IU.comment_block(["This is an autogenerated file",
                                 "all changes will be overwritten"], 80)
    preamble.append('#include "large_float.h"')
    preamble.append('#include "interval.h"')
    preamble.append('#include "box.h"')
    preamble.append('#include "function.h"')
    preamble.append('')
    preamble.append('extern interval')
    preamble.append('function(const box & X_wrapped)')
    preamble.append('{')
    preamble.append('box_t X = X_wrapped.get_value();')
    preamble.append('    return interval({});'.format(function))
    preamble.append('}')
    preamble.append('')

    return preamble




def write_function_source(filename, function):
    body = create_function_body(function)

    with open(filename, 'w') as f:
        f.write('\n'.join(body))




def reformat_function(function):
    return function



def main():
    global GU

    arg_dict = parse_args()

    full_dir = P.abspath(P.dirname(SYS.argv[0]))
    base_dir = P.split(full_dir)[0]
    bin_dir = P.join(base_dir, "bin/")
    src_dir = P.join(base_dir, "src/")
    include_dir = P.join(base_dir, "include/")
    generated_dir = P.join(base_dir, "generated/")
    
    function = reformat_function(arg_dict["function"])

    write_function_source(P.join(generated_dir, "function.cc"), function)

    IU.log(1, IU.cyan("Compiling"))

    OS.chdir(base_dir)
    compile_time, output = IU.time_func(IU.run, "make", ["solver"],
                                        "Unable to compile")

    import gelpia_utils as GU
    import_solver(arg_dict["solver"])

    X_0, dimentions = parse_box(arg_dict["input"])

    profiler = None
    if (arg_dict["profile"]):
        profiler = LP.LineProfiler(SOLVER.solve)
        profiler.enable()

    try:
        start = T.time()
        IU.log(1, IU.cyan("Running"))
        answer = SOLVER.solve(X_0,
                              GU.large_float(arg_dict["input_epsilon"]),
                              GU.large_float(arg_dict["output_epsilon"]),
                              GU.function,
                              arg_dict["threads"],
                              profiler)
    finally:
        end = T.time()

        if (arg_dict["profile"]):
            profiler.disable()
            profiler.print_stats()
        
    IU.log(0, IU.green("Compile time: ")+str(compile_time))
    IU.log(0, IU.green("Solver time: ")+str(end-start))
    print(IU.green("Answer: ")+str(answer))


    
if __name__ == "__main__":
    main()
