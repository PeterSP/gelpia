#!/usr/bin/env python3

import ian_utils as IU
import line_profiler as LP
import argparse as AP
import time as T
import sys as SYS
import os.path as P
import os as OS
import ast as AST
import re as RE
import sys as SYS

# Mapping from command line names of solvers to internal names used for importing
solvers = {"serial"                 : "serial",
           "s"                      : "serial",
           "priority_serial"        : "priority_serial",
           "ps"                     : "priority_serial",
           "naive_parallel"         : "naive_parallel",
           "np"                     : "naive_parallel",
	   "split_parallel"         : "split_parallel",
	   "sp"                     : "split_parallel",
           "feeder_parallel"        : "feeder_parallel",
           "fp"                     : "feeder_parallel",
           "map_parallel"           : "map_parallel",
           "mp"                     : "map_parallel",
           "map_serial"             : "map_serial",
           "ms"                     : "map_serial"}

GU = None # global module name that wil be imported later
SOLVER = None # global module name that wil be imported later

def import_solver(solver):
    """ Takes in a name which must be a key in the global `solvers` and imports
    that solver as the global name SOLVER """
    global SOLVER # so we can change the global

    # This is a workaround since you cant `import solvers[solver] as SOLVER`
    if solvers[solver] == "serial":
        import serial_solver as SOLVER
    elif solvers[solver] == "priority_serial":
        import priority_serial_solver as SOLVER
    elif solvers[solver] == "naive_parallel":
        import naive_parallel_solver as SOLVER
    elif solvers[solver] == "split_parallel":
        import split_parallel_solver as SOLVER
    elif solvers[solver] == "feeder_parallel":
        import feeder_parallel_solver as SOLVER
    elif solvers[solver] == "map_serial":
        import map_serial_solver as SOLVER
    elif solvers[solver] == "map_parallel":
        import map_parallel_solver as SOLVER
    else:
        IU.error("Solver not fully integrated")
        SYS.exit(-1)




def parse_box2(box_string):
    #mark please comment this function
    # Put numbers in strings
#    num_re = r"((?:-?\d+\.\d+)|(?:-?\d+\.)|(?:-?\.\d+)|(?:-?\d+))"
#    interval_re = r"\((" + num_re + r"),\s*(" + num_re + ")\)"
    import input_parser
    box_string = input_parser.process(box_string[0])
#    box_string = RE.sub(interval_re,
#                        lambda m: '("{}", "{}")'.format(m.group(1), m.group(3)),
#                        box_string[0])
    python_box = AST.literal_eval(box_string)
    variables = dict()
    index = 0
    box = []
    try:
        dimensions = len(python_box)
        for pair in python_box.keys():
            variables[pair] = index
            index += 1
            pair = python_box[pair]
            if (len(pair) != 2):
                IU.error("Interval must be a N by 2 list.")
                IU.error("item <{}> is of length {}".format(pair, len(pair)))
                SYS.exit()
            if (not isinstance(pair[0], str) or
                not isinstance(pair[1], str)):
                IU.error("Improve this error 0")
                SYS.exit()
            box.append(pair)

        return (box, dimensions, variables)

    except:
        IU.error("Improve this error 1")
        raise
        SYS.exit()





def parse_args():
    """ Command line argumetn parser. Returns a dict from arg name to value"""

    # Using the Ian argument parser since it has nicer from file characteristics
    parser = IU.IanArgumentParser(description="Global function optimizer based "
                                  "on branch and bound for noncontinuous "
                                  "functions.",
                                  fromfile_prefix_chars='@')
    # Verbosity level
    parser.add_argument("-v", "--verbose", help="increase output verbosity",
                        type=int)
    # All flags have descriptions
    parser.add_argument("-p", "--profile",
                        help="profile the solver",
                        action="store_true")
    parser.add_argument("-t", "--threads",
                        help="number of threads to use",
                        type=int, default=1)
    parser.add_argument("-ie", "--input-epsilon",
                        help="cuttoff for function input size",
                        type=float, default=.001)
    parser.add_argument("-oe", "--output-epsilon",
                        help="cuttoff for function output size",
                        type=float, default=.001)
    parser.add_argument("-s", "--solver",
                        help="solver to use",
                        choices = solvers.keys(), type=str, default="serial")
    parser.add_argument("-i", "--input",
                        help="Search space",
                        type=str, nargs='+', required=True,)
    parser.add_argument("-f", "--function",
                        help="the c++ interval arithmatic function to evaluate",
                        type=str, nargs='+', required=True,)

    # actually parse
    args = parser.parse_args()

    # set verbosity level
    if args.verbose:
        IU.set_log_level(args.verbose)

    # grab function (this is required since the function may have spaces in it)
    # `input` is handled differently
    function = ' '.join(args.function)

    return {"input_epsilon"  : str(args.input_epsilon),
            "output_epsilon" : str(args.output_epsilon),
            "input"          : args.input,
            "function"       : function,
            "solver"         : args.solver,
            "threads"        : args.threads,
            "profile"        : args.profile}




def create_function_body(function, variables):
    #mark please comment this function
    preamble = IU.comment_block(["This is an autogenerated file",
                                 "all changes will be overwritten"], 80)
    preamble.append('#include "large_float.h"')
    preamble.append('#include "interval.h"')
    preamble.append('#include "box.h"')
    preamble.append('#include "function.h"')
    preamble.append('')
    preamble.append('extern interval')
    preamble.append('function(const box & X_wrapped)')
    preamble.append('{')
    if len(variables) != 0:
        preamble.append('const box_t & X = X_wrapped.get_value();')
    preamble.append(function)
#    preamble.append('    return interval({});'.format(function))
    preamble.append('}')
    preamble.append('')

    return preamble


def write_function_source(filename, function, variables):
    """ Writes the given function to the given file as a c++ function """
    body = create_function_body(function, variables)
    with open(filename, 'w') as f:
        f.write('\n'.join(body))


def reformat_function(function, variables):
    """ Takes a math formatted function with variables and translates it to
    c++ """
    import rewriter.reader
    return rewriter.reader.get_body(function,variables)


def make_X_0(box_list):
    """ Makes a GU.box from the given python structure"""
    box = GU.box()
    for i in range(len(box_list)):
        box.append(box_list[i][0], box_list[i][1])
    return box




def main():
    global GU # so we can change the global

    arg_dict = parse_args()

    # Directory names used in this script
    full_dir = P.abspath(P.dirname(SYS.argv[0])) # Directory for this script
    base_dir = P.split(full_dir)[0] # One directory up
    bin_dir = P.join(base_dir, "bin/") # Directories within that directroy
    src_dir = P.join(base_dir, "src/")
    include_dir = P.join(base_dir, "include/")
    generated_dir = P.join(base_dir, "generated/")

    # Grab input interval variables, use them for the fucntion translation,
    # and write them out to a c++ file
    start_box, dimensions, variables = parse_box2(arg_dict["input"])
    function = reformat_function(arg_dict["function"], variables)
    write_function_source(P.join(generated_dir, "function.cc"), function, variables)

    # Use the makefile to compile everything required
    # (If source files have been changed outside of our knowledge we want them
    # to be compiled)
    IU.log(1, IU.cyan("Compiling"))
    OS.chdir(base_dir)
    compile_time, output = IU.time_func(IU.run, "make", ["solver"],
                                        "Unable to compile")

    # Import generated module, solver module, and create c++ box
    import gelpia_utils as GU
    import_solver(arg_dict["solver"])
    X_0 = make_X_0(start_box)

    # Set profiler if requested
    profiler = None
    if (arg_dict["profile"]):
        profiler = LP.LineProfiler(SOLVER.solve)
        profiler.enable()

    # Use try so that we can print profiling information if canceled early
    maximum = "incomplete search"
    input_for_maximum = "incomplete search"
    try:
        start = T.time()
        IU.log(1, IU.cyan("Running"))
        tup = SOLVER.solve(X_0,
                           GU.large_float(arg_dict["input_epsilon"]),
                           GU.large_float(arg_dict["output_epsilon"]),
                           GU.function,
                           arg_dict["threads"],
                           profiler)
        maximum, input_for_maximum = tup
    finally:
        end = T.time()

        if (arg_dict["profile"]):
            profiler.disable()
            profiler.print_stats()

    IU.log(0, IU.green("Compile time: ")+str(compile_time))
    IU.log(0, IU.green("Solver time: ")+str(end-start))
    print(IU.green("Maximum: ")+str(maximum))
    if len(variables) != 0:
            print(IU.green("Input for maximum: "))
            intervals = []
            for v in variables.keys():
                intervals.append(v + ": " + str(input_for_maximum[variables[v]]))
            intervals.sort()
            print("\n".join(intervals))



if __name__ == "__main__":
    main()
