#!/usr/bin/env python3

import ian_utils as IU
import argparse as AP
import time as T
import sys as SYS
import os.path as P
import os as OS

#import serial_solver as SS
SS = "hello"
solvers = {"serial" : SS,}


def parse_args():
    parser = IU.IanArgumentParser(description="Temporary description",
                               fromfile_prefix_chars='@')
    parser.add_argument("-v", "--verbose", help="increase output verbosity",
                        type=int)
    parser.add_argument("-t", "--threads", help="number of threads to use",
                        type=int, default=1)
    parser.add_argument("-ie", "--input-epsilon",
                        help="cuttoff for function input size",
                        type=float, default=.001)
    parser.add_argument("-oe", "--output-epsilon",
                        help="cuttoff for function output size",
                        type=float, default=.001)
    parser.add_argument("-s", "--solver",
                        help="solver to use",
                        choices = solvers.keys(),
                        type=str, default="serial")
    parser.add_argument("-f", "--function",
                        nargs='+', required=True,
                        help="the c++ interval arithmatic function to evaluate",
                        type=str)

    args = parser.parse_args() 

    if args.verbose:
        IU.set_log_level(args.verbose)
        
    function = ' '.join(args.function)


    return {"input_epsilon"  : args.input_epsilon,
            "output_epsilon" : args.output_epsilon,
            "function"       : function,
            "solver"         : args.solver,
            "threads"        : args.threads}




def create_function_body(function):
    preamble = IU.comment_block(["This is an autogenerated file",
                                 "all changes will be overwritten"], 80)
    preamble.append('#include "gelpia_utils.h"')
    preamble.append('')
    preamble.append('extern interval_t')
    preamble.append('function_under_test(const box_t & X)')
    preamble.append('{')
    preamble.append('    return {};'.format(function))
    preamble.append('}')
    preamble.append('')

    return preamble




def write_function_source(filename, function):
    body = create_function_body(function)

    with open(filename, 'w') as f:
        f.write('\n'.join(body))




def reformat_function(function):
    return function




def main():
    arg_dict = parse_args()

    full_dir = P.dirname(SYS.argv[0])
    base_dir = P.split(full_dir)[0]
    bin_dir = P.join(base_dir, "bin/")
    src_dir = P.join(base_dir, "src/")
    include_dir = P.join(base_dir, "include/")
    generated_dir = P.join(base_dir, "generated/")
    
    function = reformat_function(arg_dict["function"])

    write_function_source(P.join(generated_dir, "function.cc"), function)

    compile_args_list = ["-std=c++11",
                         "-Wall",
                         "-Werror",
                         "-g",
                         "-lmpfr",
                         "-I"+include_dir,
                         "-o "+P.join(bin_dir, "gelpia_solver"),
                         P.join(src_dir, solvers[arg_dict["solver"]])]

    IU.log(1, IU.cyan("Compiling"))

    compile_time, output = IU.time_func(IU.run,
                                        "clang++", compile_args_list,
                                        "Unable to compile")


    run_args_list = ["-v {}".format(IU.get_log_level()),
                     "-ie {}".format(arg_dict["input_epsilon"]),
                     "-oe {}".format(arg_dict["output_epsilon"]),
                     "-t {}".format(arg_dict["threads"])]
    IU.log(1, IU.cyan("Running"))
    run_time, answer = IU.time_func(IU.run,
                                   P.join(bin_dir,"gelpia_solver"),
                                   run_args_list,
                                   "Unable to run solver")

    print("")
    IU.log(0, IU.green("Compile time: ")+str(compile_time)+" seconds")
    IU.log(0, IU.green("Run time: ")+str(run_time)+" seconds")
    print(IU.green("Answer: ")+str(answer))

    
if __name__ == "__main__":
    main()
